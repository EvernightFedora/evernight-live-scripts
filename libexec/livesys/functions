#!/bin/sh
# Functions to be used with livesys-* scripts

# Check if gettext exists
if ! type gettext > /dev/null 2>&1; then
  # If not, create a dummy function that returns the input verbatim
  gettext() { printf '%s' "$1"; }
fi

# returns OK if $1 contains literal string $2 (and isn't empty)
strstr() {
    [ "${1##*"$2"*}" != "$1" ]
}

# Run some action. Log its output.
action() {
    local STRING rc

    STRING=$1
    printf '%s' "$(gettext "${STRING} ")"
    shift
    if "$@"; then
        success "$(gettext "${STRING} ")"
    else
        failure "$(gettext "${STRING} ")"
    fi
    rc=$?
    printf '\n'
    return $rc
}

# verbose ->> very (very!) old bootup look (prior to RHL-6.0?)
# color ->> default bootup look
# other ->> default bootup look without ANSI colors or positioning
BOOTUP=color
# Column to start "[  OK  ]" label in:
RES_COL=60
# terminal sequence to move to that column:
MOVE_TO_COL="printf \\033[${RES_COL}G"
# Terminal sequence to set color to a 'success' (bright green):
SETCOLOR_SUCCESS="printf \\033[1;32m"
# Terminal sequence to set color to a 'failure' (bright red):
SETCOLOR_FAILURE="printf \\033[1;31m"
# Terminal sequence to set color to a 'warning' (bright yellow):
SETCOLOR_WARNING="printf \\033[1;33m"
# Terminal sequence to reset to the default color:
SETCOLOR_NORMAL="printf \\033[0;39m"

# NOTE: /dev/ttyS* is serial console.
# 'not a tty' is reported when executed under systemd service units
# where /dev/null is associated with standard input 

test_tty=$(LC_ALL=C tty)
case "$test_tty" in
    /dev/ttyS* | 'not a tty')
        BOOTUP=serial
        MOVE_TO_COL=
        SETCOLOR_SUCCESS=
        SETCOLOR_FAILURE=
        SETCOLOR_WARNING=
        SETCOLOR_NORMAL=
        ;;
esac

# Log that something succeeded
success() {
    [ "$BOOTUP" != "verbose" ] && echo_success
    return 0
}

# Log that something failed
failure() {
    local rc=$?
    [ "$BOOTUP" != "verbose" ] && echo_failure
    [ -x /bin/plymouth ] && /bin/plymouth --details
    return $rc
}

echo_success() {
    [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
    printf '%s' "["
    [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
    printf '%s' "$(gettext "  OK  ")"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    printf '%s' "]"
    printf '\r'
    return 0
}

echo_failure() {
    [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
    printf '%s' "["
    [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
    printf '%s' "$(gettext "FAILED")"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    printf '%s' "]"
    printf '\r'
    return 1
}

fscheck() {
    local fstype="$1"
    local fs="$2"
    local d="${3:-$2}"
    umount "$fs" >/dev/null 2>&1 || :
    case "$fstype" in
        ext[432])
            printf '\n'
            flock "$d" e2fsck -yfv "$fs" || :
            ;;
        vfat|msdos)
            printf '\n'
            flock "$d" fsck.fat -avVw "$fs"
            ;;
        btrfs)
            printf '# btrfs check -p --repair --force'
            flock "$d" btrfs check -p --repair --force "$fs"
            ;;
        xfs)
            printf '\n# xfs_repair -v'
            flock "$d" xfs_repair -v "$fs"
            ;;
        f2fs)
            printf '# fsck.f2fs -afy'
            flock "$d" fsck.f2fs -afy "$fs"
            ;;
        *)
            printf "\n\tERROR:   Filesystem checking for '%s' is not\n \
                available.\n" "$fstype"
    esac
}

